[[C-git-commands]]
[appendix]
== Ukazi Git

Skozi knjigo smo predstavili desetine ukazov Git in se trudili, da bi jih predstavili znotraj neke vrste pripovedi s postopnim dodajanjem več ukazov v zgodbo.
Vendar pa to pusti primere uporabe ukazov nekoliko razpršene po celotni knjigi.

V tem dodatku bomo pregledali vse ukaze Git, ki smo jih obravnavali v knjigi, približno razvrščene glede na to, za kaj se uporabljajo.
Govorili bomo o tem, kaj vsak ukaz na splošno naredi, in nato poudarili, kje v knjigi smo ga uporabili.

[TIP]
====
Dolge možnosti lahko skrajšate.
Na primer, vtipkate lahko `git commit --a`, kar deluje tako, kot da bi vtipkali `git commit --amend`.
To deluje samo, če so črke po `--` edinstvene za eno možnost.
Pri pisanju skript uporabljajte polno opcijo.
====

=== Nastavitev in konfiguracija

Obstajata dva ukaza, ki se precej pogosto uporabljata od prve uporabe Gita do skupnega vsakodnevnega prilagajanja in sklicevanja: ukaza `config` in `help`.

==== git config

Git ima privzeti način za izvajanje na stotine stvari.
Za veliko teh stvari lahko Gitu poveste, naj jih privzeto izvaja drugače ali nastavite svoje preference.
To vključuje vse, od tega, da poveste Gitu, kako vam je ime, do določenih nastavitev barv terminala ali kateri urejevalnik uporabljate.
Obstaja več datotek, ki jih bo ta ukaz prebral in zapisal, tako da lahko vrednosti nastavite globalno ali do specifičnih repozitorijev.

Ukaz `git config` se je uporabljal v skoraj vsakem poglavju knjige.

V poglavju <<ch01-getting-started#_first_time>> smo ga uporabili, da smo pred začetkom uporabe Gita določili naše ime, e-poštni naslov in nastavitve urejevalnika.

V poglavju <<ch02-git-basics-chapter#_git_aliases>> smo pokazali, kako ga lahko uporabite za ustvarjanje okrajšanih ukazov, ki se razširijo v dolge zaporedne možnosti, da jih ni treba vsakič tipkati.

V poglavju <<ch03-git-branching#_rebasing>> smo ga uporabili, da smo določili privzeto vedenje `--rebase`, ko zaženemo ukaz `git pull`.

V poglavju <<ch07-git-tools#_credential_caching>> smo ga uporabili, da smo nastavili privzeto skladišče za vaša HTTP gesla.

V poglavju <<ch08-customizing-git#_keyword_expansion>> smo pokazali, kako nastaviti t.i. filtre smudge in clean na vsebino, ki prihaja in odhaja iz Gita.

Nazadnje, je skoraj celotno poglavje <<ch08-customizing-git#_git_config>> posvečeno temu ukazu.

[[ch_core_editor]]
==== Ukazi git config core.editor

Poleg navodil za nastavitve konfiguracije v <<ch01-getting-started#_editor>>, se lahko mnogi urejevalniki nastavijo na naslednji način:

.Izčrpen seznam konfiguracijskih ukazov `core.editor`
[cols="1,2",options="header"]
|==============================
|Urejevalnik | Konfiguracijski ukaz
|Atom |`git config --global core.editor "atom --wait"`
|BBEdit (Mac, with command line tools) |`git config --global core.editor "bbedit -w"`
|Emacs |`git config --global core.editor emacs`
|Gedit (Linux) |`git config --global core.editor "gedit --wait --new-window"`
|Gvim (Windows 64-bit) |`git config --global core.editor "'C:\Program Files\Vim\vim72\gvim.exe' --nofork '%*'"` (Also see note below)
|Kate (Linux) |`git config --global core.editor "kate"`
|nano |`git config --global core.editor "nano -w"`
|Notepad (Windows 64-bit) |`git config core.editor notepad`
|Notepad++ (Windows 64-bit) |`git config --global core.editor "'C:\Program Files\Notepad++\notepad++.exe' -multiInst -notabbar -nosession -noPlugin"` (Also see note below)
|Scratch (Linux)|`git config --global core.editor "scratch-text-editor"`
|Sublime Text (macOS) |`git config --global core.editor "/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl --new-window --wait"`
|Sublime Text (Windows 64-bit) |`git config --global core.editor "'C:\Program Files\Sublime Text 3\sublime_text.exe' -w"` (Also see note below)
|TextEdit (macOS)|`git config --global core.editor "open --wait-apps --new -e"`
|Textmate |`git config --global core.editor "mate -w"`
|Textpad (Windows 64-bit) |`git config --global core.editor "'C:\Program Files\TextPad 5\TextPad.exe' -m` (Also see note below)
|UltraEdit (Windows 64-bit) | `git config --global core.editor Uedit32`
|Vim |`git config --global core.editor "vim --nofork"`
|Visual Studio Code |`git config --global core.editor "code --wait"`
|VSCodium (Free/Libre Open Source Software Binaries of VSCode) | `git config --global core.editor "codium --wait"`
|WordPad |`git config --global core.editor '"C:\Program Files\Windows NT\Accessories\wordpad.exe"'"`
|Xi | `git config --global core.editor "xi --wait"`
|==============================

[NOTE]
====
Če imate na sistemih 64-bitni sistemu Windows 32-bitni urejevalnik, bo program nameščen v `C:\Program Files (x86)\`, namesto v `C:\Program Files\`, kot je prikazano v zgornji tabeli.
====

==== git help

Ukaz `git help` se uporablja za prikaz dokumentacije, ki jo Git vsebuje o katerem koli ukazu.
Čeprav smo v tem dodatku podali grob pregled večine najbolj priljubljenih ukazov, lahko vedno za celoten seznam vseh možnih možnosti in zastavic za vsak ukaz zaženete `git help <ukaz>`.

Ukaz `git help` smo predstavili v <<ch01-getting-started#_git_help>> in prikazali, kako ga uporabiti za iskanje dodatnih informacij o `git shell` v <<ch04-git-on-the-server#_setting_up_server>>.


=== Pridobivanje in ustvarjanje projektov

Obstajata dva načina za pridobivanje repozitorijev Git.
Eden je kopiranje iz obstoječega repozitorija v omrežju ali drugje, druga pa je ustvarjanje novega v obstoječem imeniku.

==== git init

Da bi iz imenika ustvarili novi repozitorij Git in začeli uporabljati nadzor različic, preprosto zaženete `git init`.

To smo najprej predstavili v <<ch02-git-basics-chapter#_getting_a_repo>>, kjer smo ustvarili popolnoma nov repozitorij, s katerim smo začeli delati.

Na kratko smo govorili o tem, kako lahko privzeto ime veje spremenite iz "`master`" v <<ch03-git-branching#_remote_branches>>.

Ta ukaz smo uporabili za ustvarjanje praznega golega repozitorija za strežnik v <<ch04-git-on-the-server#_bare_repo>>.

Nazadnje pa smo v <<ch10-git-internals#_plumbing_porcelain>> podrobno razložili, kaj ukaz dejansko počne za zavesami.

==== git clone

Ukaz `git clone` je dejansko nekakšen ovitek okoli več drugih ukazov.
Ustvari novo mapo, vstopi vanjo in zažene `git init`, da naredi prazen repozitorij Git, doda oddaljeni strežnik (`git remote add`) na naslov URL, ki se mu ga prenese (privzeto poimenovan `origin`), zažene `git fetch` iz tega oddaljenega repozitorija in nato z `git checkout` preveri najnovejši predložek v vaši delovni mapi.

Ukaz `git clone` se uporablja na desetinah mest po knjigi, vendar bomo našteli le nekaj zanimivih.

Uvodoma je predstavljen in pojasnjen v <<ch02-git-basics-chapter#_git_cloning>>, kjer predstavimo nekaj primerov.

V poglavju <<ch04-git-on-the-server#_getting_git_on_a_server>> preučujemo uporabo možnosti `--bare`, da ustvarimo kopijo repozitorija Git brez delovne mape.

V poglavju <<ch07-git-tools#_bundling>> ga uporabimo za razpakiranje zapakiranega repozitorija Git.

Končno pa v poglavju <<ch07-git-tools#_cloning_submodules>> spoznamo možnost `--recurse-submodules`, ki poenostavi kloniranje repozitorija z vdelanimi podmoduli.

Čeprav se uporablja na mnogih drugih mestih v knjigi, so to tista, ki so nekoliko edinstvena ali kjer se uporablja na načine, ki se nekoliko razlikujejo.


=== Osnove posnetkov

Za osnovni potek dela s posnetki vsebine in potrjevanjem v zgodovino je le nekaj osnovnih ukazov.

==== git add

Ukaz `git add` doda vsebino iz delovnega direktorija v področje priprave podatkov (ali "`indeks`") za naslednjo potrditev.
Ko se zažene ukaz `git commit`, privzeto pogleda le to področje za pripravo, zato se ukaz `git add` uporablja za urejanje, kaj želite imeti v naslednjem posnetku potrditve.

Ta ukaz je izjemno pomemben ukaz v Gitu in je v tej knjigi omenjen ali uporabljen na desetine časa.
Hitro bomo pokrili nekatere edinstvene načine uporabe.

Najprej podrobno predstavimo in razložimo `git add` v poglavju <<ch02-git-basics-chapter#_tracking_files>>.

V poglavju <<ch03-git-branching#_basic_merge_conflicts>> omenimo, kako ga uporabiti za reševanje konfliktov združevanja.

V poglavju <<ch07-git-tools#_interactive_staging>> preidemo na uporabo interaktivnega področja za pripravo samo določenih delov spremenjene datoteke.

Končno ga v poglavju <<ch10-git-internals#_tree_objects>> emuliramo na nizki ravni, tako da lahko dobite idejo, kaj počne za zavesami.

==== git status

Ukaz `git status` vam bo pokazal različna stanja datotek v vašem delovnem direktoriju in področju priprave.
Katere datoteke so spremenjene in niso v področju priprave ter katere so v področju priprave, vendar še niso bile potrjene.
V svoji običajni obliki vam bo tudi pokazal nekaj osnovnih namigov, kako premikati datoteke med temi stopnjami.

Najprej obravnavamo `status` v poglavju <<ch02-git-basics-chapter#_checking_status>>, tako v svojih osnovnih kot poenostavljenih oblikah.
Čeprav ga uporabljamo skozi celotno knjigo, je tam zajeto praktično vse, kar lahko storite z ukazom `git status`.

==== git diff

Ukaz `git diff` se uporablja, ko želite videti razlike med katerima koli dvema drevesoma.
To bi lahko bila razlika med vašim delovnim okoljem in področjem priprave (`git diff` sam po sebi), med področjem priprave in zadnjim potrjenim stanjem (`git diff --staged`) ali med dvema potrjenima stanjema (`git diff master branchB`).

Najprej si ogledamo osnovne uporabe ukaza `git diff` v poglavju <<ch02-git-basics-chapter#_git_diff_staged>>, kjer prikažemo, kako si ogledati, katere spremembe so pripravljene in katere še niso.

Uporabljamo ga za iskanje morebitnih težav s presledki pred potrditvijo z možnostjo `--check` v poglavju <<ch05-distributed-git#_commit_guidelines>>.

Prikažemo, kako preveriti razlike med vejami bolj učinkovito s sintakso `git diff A...B` v poglavju <<ch05-distributed-git#_what_is_introduced>>.

Uporabljamo ga za filtriranje razlik med presledki z `-b` in primerjavo različnih stopenj konfliktnih datotek z `--theirs`, `--ours` in `--base` v poglavju <<ch07-git-tools#_advanced_merging>>.

Nazadnje ga uporabimo za učinkovito primerjavo sprememb podmodulov z možnostjo `--submodule` v poglavju <<ch07-git-tools#_starting_submodules>>.

==== git difftool

Ukaz `git difftool` preprosto zažene zunanje orodje, ki vam prikaže razliko med dvema drevesoma, v primeru, da želite uporabiti kaj drugega kot le vgrajeni `git diff` ukaz.

To le kratko omenimo v <<ch02-git-basics-chapter#_git_diff_staged>>.

==== git commit

Ukaz `git commit` vzame vsebino datotek, ki so bile dane v pripravo z `git add` in zabeleži nov trajni posnetek v bazi podatkov in nato premakne kazalec veje na trenutni veji.

Osnove za izvajanje posnetkov predstavimo v <<ch02-git-basics-chapter#_committing_changes>>.
Tam prikažemo tudi, kako uporabiti zastavico `-a`, da preskočite korak `git add` v vsakodnevnih delovnih procesih in kako uporabiti zastavico `-m`, da na ukazni vrstici predate sporočilo za potrditev namesto zagona urejevalnika.

V poglavju <<ch02-git-basics-chapter#_undoing>> predstavimo uporabo možnosti `--amend`, s katero lahko ponovno opravite zadnjo potrditev.

V poglavju <<ch03-git-branching#_git_branches_overview>> gremo v podrobnosti, kaj `git commit` naredi in zakaj to počne na ta način.

Kako podpisati posnetke kriptografsko z zastavico `-S` smo pogledali v poglavju <<ch07-git-tools#_signing_commits>>.

Nazadnje pogledamo, kaj ukaz `git commit` naredi v ozadju in kako je dejansko izveden v poglavju <<ch10-git-internals#_git_commit_objects>>.

==== git reset

Ukaz `git reset` se uporablja predvsem za razveljavitev stvari, kot se morda lahko sklepa iz glagola.
Kazalec `HEAD` premakne in po potrebi spremeni kazalec `index` ali področje priprave in poleg tega lahko z možnostjo `--hard` po potrebi spremeni delovni imenik.
S to končno možnostjo je mogoče izgubiti delo, če se uporabi napačno, zato se prepričajte, da ga razumete, preden ga uporabite.

Najprej obravnavamo najpreprostejšo uporabo ukaza `git reset` v poglavju <<ch02-git-basics-chapter#_unstaging>>, kjer ga uporabimo za razveljavitev priprave datoteke, na kateri smo že uporabili ukaz `git add`.

Podrobno ga obravnavamo v poglavju <<ch07-git-tools#_git_reset>>, ki je v celoti posvečeno razlagi tega ukaza.

Ukaz `git reset --hard` uporabimo za preklic združevanja v poglavju <<ch07-git-tools#_abort_merge>>, kjer uporabimo tudi ukaz `git merge --abort`, ki je nekolikšen ovoj za ukaz `git reset`.

==== git rm

Ukaz `git rm` se uporablja za odstranjevanje datotek iz področja priprave in delovnega direktorija Git.
Podobno kot ukaz `git add`, tudi ta ukaz pripravi odstranitev datoteke za naslednjo potrditev.

V poglavju <<ch02-git-basics-chapter#_removing_files>> podrobneje obravnavamo ukaz `git rm`, vključno z rekurzivnim odstranjevanjem datotek in odstranjevanjem datotek samo iz področja priprave, vendar jih pustimo v delovnem direktoriju z uporabo možnosti `--cached`.

Edina druga različna uporaba ukaza `git rm` v knjigi je v poglavju <<ch10-git-internals#_removing_objects>>, kjer na kratko uporabimo in pojasnimo uporabo možnosti `--ignore-unmatch` pri izvajanju ukaza `git filter-branch`, kar preprosto preprečuje, da bi se prijavila napaka, ko datoteke, ki jih želimo odstraniti, ni.
To lahko koristi za skriptiranje.

==== git mv

Ukaz `git mv` je preprost ukaz, ki omogoča premikanje datotek in nato se izvede ukaz `git add` na novi datoteki ter ukaz `git rm` na stari datoteki.

Ta ukaz samo na kratko omenimo v poglavju <<ch02-git-basics-chapter#_git_mv>>.

==== git clean

Ukaz `git clean` se uporablja za odstranjevanje nepotrebnih datotek iz vašega delovnega direktorija.
To lahko vključuje odstranjevanje začasnih artefaktov gradnje ali datotek z združitvenimi konflikti.

Veliko možnosti in scenarijev, v katerih bi uporabili ukaz clean, obravnavamo v poglavju <<ch07-git-tools#_git_clean>>.

=== Veje in združevanje

V Gitu obstaja kar nekaj ukazov, ki omogočajo večino funkcionalnosti razvejanja in združevanja.

==== git branch

Ukaz `git branch` je v resnici nekakšno orodje za upravljanje vej.
Omogoča vam izpis seznama vej, ustvarjanje novih vej, brisanje in preimenovanje vej.

Večino poglavja <<ch03-git-branching#ch03-git-branching>> je namenjenega ukazu `branch`, ki ga uporabljamo skozi celotno poglavje.
Prvič ga predstavimo v poglavju <<ch03-git-branching#_create_new_branch>>, večino njegovih drugih funkcij (seznam in brisanje) pa opišemo v poglavju <<ch03-git-branching#_branch_management>>.

V poglavju <<ch03-git-branching#_tracking_branches>> uporabimo možnost `git branch -u`, da nastavimo sledenje veji.

Na koncu pa opišemo nekaj njegovih ozadij v poglavju <<ch10-git-internals#_git_refs>>.

==== git checkout

Ukaz `git checkout` se uporablja za preklapljanje med vejami in preverjanje vsebine v delovnem imeniku.

Prvič se srečamo z ukazom v poglavju <<ch03-git-branching#_switching_branches>> skupaj z ukazom `git branch`.

V poglavju <<ch03-git-branching#_tracking_branches>> prikažemo, kako ga uporabiti za sledenje vejam z zastavico `--track`.

V poglavju <<ch07-git-tools#_checking_out_conflicts>> ga uporabimo, da ponovno uvedemo konflikte med datotekami z `--conflict=diff3`.

V poglavju <<ch07-git-tools#_git_reset>> podrobneje opišemo njegovo razmerje z ukazom `git reset`.

Na koncu pa v poglavju <<ch10-git-internals#ref_the_ref>> podrobneje opišemo njegovo izvajanje.

==== git merge

Orodje `git merge` se uporablja za združevanje ene ali več vej v vejo, ki jo imate odprto.
Nato se trenutna veja premakne na rezultat združevanja.

Ukaz `git merge` je bil prvič predstavljen v poglavju <<ch03-git-branching#_basic_branching>>.
Čeprav se v knjigi uporablja na različnih mestih, obstaja zelo malo različic ukaza `merge` - običajno samo `git merge <branch>` z imenom ene veje, ki jo želite združiti.

V poglavju <<ch05-distributed-git#_public_project>> smo na koncu obravnavali združevanje z zdrobljenim zgodovinskim zapisom (kjer Git združi delo, vendar se pretvarja, kot da gre samo za novo potrditev, brez beleženja zgodovine veje, ki jo združujete).

V poglavju <<ch07-git-tools#_advanced_merging>> smo se veliko naučili o postopku in ukazu za združevanje, vključno z ukazom `-Xignore-space-change` in zastavico `--abort` za prekinitev težavnega združevanja.

Naučili smo se preverjati podpise pred združevanjem, če vaš projekt uporablja podpisovanje z GPG, v poglavju <<ch07-git-tools#_signing_commits>>.

Na koncu smo se v poglavju <<ch07-git-tools#_subtree_merge>> naučili o združevanju poddreves.

==== git mergetool

Ukaz `git mergetool` enostavno zažene zunanji pripomoček za združevanje v primeru težav pri združevanju v Gitu.

Omenimo ga na hitro v <<ch03-git-branching#_basic_merge_conflicts>> in podrobneje razložimo, kako lahko implementirate svoj lastni zunanji pripomoček za združevanje v <<ch08-customizing-git#_external_merge_tools>>.

==== git log

Ukaz `git log` se uporablja za prikazovanje dosegljive zabeležene zgodovine projekta od najnovejše zabeležene različice nazaj.
Privzeto prikazuje samo zgodovino veje, na kateri se trenutno nahajate, vendar lahko navedete drugačne ali celo več glav ali vej, od katerih se želite premikati.
Pogosto se uporablja tudi za prikaz razlik med dvema ali več vejami na ravni potrditev.

Ta ukaz se uporablja v skoraj vsakem poglavju knjige za prikazovanje zgodovine projekta.

Ukaz predstavimo in ga podrobno obravnavamo v <<ch02-git-basics-chapter#_viewing_history>>.
Tam si ogledamo možnosti `-p` in `--stat`, da dobimo idejo, kaj je bilo predstavljeno v vsaki potrditvi, in možnosti `--pretty` in `--oneline`, da si zgodovino ogledamo bolj jedrnato, skupaj s preprostimi možnostmi filtriranja po datumu in avtorju.

V <<ch03-git-branching#_create_new_branch>> ga uporabimo z možnostjo `--decorate`, da si lažje vizualiziramo, kje so kazalniki naših vej, in uporabimo tudi možnost `--graph`, da si ogledamo, kako izgledajo različne zgodovine.

V poglavjih <<ch05-distributed-git#_private_team>> in <<ch07-git-tools#_commit_ranges>> pokrijemo sintakso `branchA..branchB` pri uporabi ukaza `git log`, da vidimo, katere potrditve so edinstvene za vejo v primerjavi z drugo vejo.
V <<ch07-git-tools#_commit_ranges>> to precej obsežno obravnavamo.

V poglavjih <<ch07-git-tools#_merge_log>> in <<ch07-git-tools#_triple_dot>> pokrijemo uporabo formata `branchA...branchB` in sintakse `--left-right`, da vidimo, kaj je v eni veji ali drugi, vendar ne v obeh.
V poglavju <<ch07-git-tools#_merge_log>> si ogledamo tudi, kako uporabiti možnost `--merge` za pomoč pri odpravljanju konfliktov med združevanjem, in uporabo možnosti `--cc`, da si ogledamo konflikte pri združevanju potrditev v zgodovini.

V poglavju <<ch07-git-tools#_git_reflog>> uporabimo možnost `-g`, da si ogledamo Gitov reflog prek te orodne vrstice, namesto da bi prehajali po vejah.

V poglavju <<ch07-git-tools#_searching>> si ogledamo uporabo možnosti `-S` in `-L` za izvajanje precej zapletenih iskanj po nečem, kar se je zgodilo v zgodovini kode, kot je npr. ogled zgodovine funkcije.

V poglavju <<ch07-git-tools#_signing_commits>> se naučimo, kako uporabiti `--show-signature`, da dodamo potrditveno verigo k vsaki potrditvi v izpisu `git log` glede na to, ali je bilo pravilno podpisano ali ne.

==== git stash

Ukaz `git stash` se uporablja za začasno shranjevanje nezaključenega dela, da se očisti delovni direktorij, ne da bi bilo treba nedokončano delo potrditi na veji.

To je v bistvu v celoti pokrito v poglavju <<ch07-git-tools#_git_stashing>>.

==== git tag

Ukaz `git tag` se uporablja za dajanje trajnih zaznamkov določeni točki v zgodovini kode.
Navadno se uporablja za stvari, kot so izdaje.

Ta ukaz je predstavljen in podrobno obravnavan v poglavju <<ch02-git-basics-chapter#_git_tagging>> in ga v praksi uporabljamo v poglavju <<ch05-distributed-git#_tagging_releases>>.

Prav tako obravnavamo, kako ustvariti z GPG podpisano oznako z zastavico `-s` in kako jo preveriti z zastavico `-v` v poglavju <<ch07-git-tools#_signing>>.


=== Deljenje in posodabljanje projektov

V Gitu ni veliko ukazov, ki dostopajo do omrežja, saj skoraj vsi ukazi delujejo na lokalni podatkovni bazi.
Ko ste pripravljeni deliti svoje delo ali povleči spremembe od drugod, obstaja nekaj ukazov, ki se ukvarjajo z oddaljenimi repozitoriji.

==== git fetch

Ukaz `git fetch` se poveže s oddaljenim repozitorijem in prenese vse informacije iz njega, ki niso v vašem trenutnem repozitoriju, ter jih shrani v vašo lokalno podatkovno bazo.

Ta ukaz najprej obravnavamo v poglavju <<ch02-git-basics-chapter#_fetching_and_pulling>> in nadaljujemo z ogledom primerov uporabe v poglavju <<ch03-git-branching#_remote_branches>>.

Uporabljamo ga tudi v več primerih v <<ch05-distributed-git#_contributing_project>>.

Uporabljamo ga za prenos posamezne specifične reference, ki je zunaj privzetega prostora v <<ch06-github#_pr_refs>> in vidimo, kako prenesti iz svežnja v <<ch07-git-tools#_bundling>>.

V <<ch10-git-internals#_refspec>> nastavimo zelo prilagojene refspecifikacije, da `git fetch` opravi nekoliko drugačno dejanje kot privzeto.

==== git pull

Ukaz `git pull` je v bistvu kombinacija ukazov `git fetch` in `git merge`, pri čemer Git prenese iz oddaljenega repozitorija, ki ga določite, in ga takoj poskuša združiti v vejo, na kateri ste.

Ukaz na hitro predstavimo v <<ch02-git-basics-chapter#_fetching_and_pulling>> in prikažemo, kako videti, kaj bo združeno, če ga zaženete v <<ch02-git-basics-chapter#_inspecting_remote>>.

Prikažemo tudi, kako ga uporabiti za pomoč pri težavah z ponovnim baziranjem v <<ch03-git-branching#_rebase_rebase>>.

Prikažemo, kako ga uporabiti z URL-jem za enkratno pridobivanje sprememb v <<ch05-distributed-git#_checking_out_remotes>>.

Končno zelo hitro omenimo, da mu lahko s stikalom `--verify-signatures` omogočimo preverjanje, ali so potrditve, ki jih pridobivamo, podpisane z GPG, v poglavju <<ch07-git-tools#_signing_commits>>.

==== git push

The `git push` command is used to communicate with another repository, calculate what your local database has that the remote one does not, and then pushes the difference into the other repository.
It requires write access to the other repository and so normally is authenticated somehow.

We first look at the `git push` command in <<ch02-git-basics-chapter#_pushing_remotes>>.
Here we cover the basics of pushing a branch to a remote repository.
In <<ch03-git-branching#_pushing_branches>> we go a little deeper into pushing specific branches and in <<ch03-git-branching#_tracking_branches>> we see how to set up tracking branches to automatically push to.
In <<ch03-git-branching#_delete_branches>> we use the `--delete` flag to delete a branch on the server with `git push`.

Throughout <<ch05-distributed-git#_contributing_project>> we see several examples of using `git push` to share work on branches through multiple remotes.

We see how to use it to share tags that you have made with the `--tags` option in <<ch02-git-basics-chapter#_sharing_tags>>.

In <<ch07-git-tools#_publishing_submodules>> we use the `--recurse-submodules` option to check that all of our submodules work has been published before pushing the superproject, which can be really helpful when using submodules.

In <<ch08-customizing-git#_other_client_hooks>> we talk briefly about the `pre-push` hook, which is a script we can setup to run before a push completes to verify that it should be allowed to push.

Finally, in <<ch10-git-internals#_pushing_refspecs>> we look at pushing with a full refspec instead of the general shortcuts that are normally used.
This can help you be very specific about what work you wish to share.

==== git remote

The `git remote` command is a management tool for your record of remote repositories.
It allows you to save long URLs as short handles, such as "`origin`" so you don't have to type them out all the time.
You can have several of these and the `git remote` command is used to add, change and delete them.

This command is covered in detail in <<ch02-git-basics-chapter#_remote_repos>>, including listing, adding, removing and renaming them.

It is used in nearly every subsequent chapter in the book too, but always in the standard `git remote add <name> <url>` format.

==== git archive

The `git archive` command is used to create an archive file of a specific snapshot of the project.

We use `git archive` to create a tarball of a project for sharing in <<ch05-distributed-git#_preparing_release>>.

==== git submodule

The `git submodule` command is used to manage external repositories within a normal repositories.
This could be for libraries or other types of shared resources.
The `submodule` command has several sub-commands (`add`, `update`, `sync`, etc) for managing these resources.

This command is only mentioned and entirely covered in <<ch07-git-tools#_git_submodules>>.

=== Inspection and Comparison

==== git show

The `git show` command can show a Git object in a simple and human readable way.
Normally you would use this to show the information about a tag or a commit.

We first use it to show annotated tag information in <<ch02-git-basics-chapter#_annotated_tags>>.

Later we use it quite a bit in <<ch07-git-tools#_revision_selection>> to show the commits that our various revision selections resolve to.

One of the more interesting things we do with `git show` is in <<ch07-git-tools#_manual_remerge>> to extract specific file contents of various stages during a merge conflict.

==== git shortlog

The `git shortlog` command is used to summarize the output of `git log`.
It will take many of the same options that the `git log` command will but instead of listing out all of the commits it will present a summary of the commits grouped by author.

We showed how to use it to create a nice changelog in <<ch05-distributed-git#_the_shortlog>>.

==== git describe

The `git describe` command is used to take anything that resolves to a commit and produces a string that is somewhat human-readable and will not change.
It's a way to get a description of a commit that is as unambiguous as a commit SHA-1 but more understandable.

We use `git describe` in <<ch05-distributed-git#_build_number>> and <<ch05-distributed-git#_preparing_release>> to get a string to name our release file after.


=== Debugging

Git has a couple of commands that are used to help debug an issue in your code.
This ranges from figuring out where something was introduced to figuring out who introduced it.

==== git bisect

The `git bisect` tool is an incredibly helpful debugging tool used to find which specific commit was the first one to introduce a bug or problem by doing an automatic binary search.

It is fully covered in <<ch07-git-tools#_binary_search>> and is only mentioned in that section.

==== git blame

The `git blame` command annotates the lines of any file with which commit was the last one to introduce a change to each line of the file and what person authored that commit.
This is helpful in order to find the person to ask for more information about a specific section of your code.

It is covered in <<ch07-git-tools#_file_annotation>> and is only mentioned in that section.

==== git grep

The `git grep` command can help you find any string or regular expression in any of the files in your source code, even older versions of your project.

It is covered in <<ch07-git-tools#_git_grep>> and is only mentioned in that section.

=== Patching

A few commands in Git are centered around the concept of thinking of commits in terms of the changes they introduce, as though the commit series is a series of patches.
These commands help you manage your branches in this manner.

==== git cherry-pick

The `git cherry-pick` command is used to take the change introduced in a single Git commit and try to re-introduce it as a new commit on the branch you're currently on.
This can be useful to only take one or two commits from a branch individually rather than merging in the branch which takes all the changes.

Cherry picking is described and demonstrated in <<ch05-distributed-git#_rebase_cherry_pick>>.

==== git rebase

The `git rebase` command is basically an automated `cherry-pick`.
It determines a series of commits and then cherry-picks them one by one in the same order somewhere else.

Rebasing is covered in detail in <<ch03-git-branching#_rebasing>>, including covering the collaborative issues involved with rebasing branches that are already public.

We use it in practice during an example of splitting your history into two separate repositories in <<ch07-git-tools#_replace>>, using the `--onto` flag as well.

We go through running into a merge conflict during rebasing in <<ch07-git-tools#ref_rerere>>.

We also use it in an interactive scripting mode with the `-i` option in <<ch07-git-tools#_changing_multiple>>.

==== git revert

The `git revert` command is essentially a reverse `git cherry-pick`.
It creates a new commit that applies the exact opposite of the change introduced in the commit you're targeting, essentially undoing or reverting it.

We use this in <<ch07-git-tools#_reverse_commit>> to undo a merge commit.

=== Email

Many Git projects, including Git itself, are entirely maintained over mailing lists.
Git has a number of tools built into it that help make this process easier, from generating patches you can easily email to applying those patches from an email box.

==== git apply

The `git apply` command applies a patch created with the `git diff` or even GNU diff command.
It is similar to what the `patch` command might do with a few small differences.

We demonstrate using it and the circumstances in which you might do so in <<ch05-distributed-git#_patches_from_email>>.

==== git am

The `git am` command is used to apply patches from an email inbox, specifically one that is mbox formatted.
This is useful for receiving patches over email and applying them to your project easily.

We covered usage and workflow around `git am` in <<ch05-distributed-git#_git_am>> including using the `--resolved`, `-i` and `-3` options.

There are also a number of hooks you can use to help with the workflow around `git am` and they are all covered in <<ch08-customizing-git#_email_hooks>>.

We also use it to apply patch formatted GitHub Pull Request changes in <<ch06-github#_email_notifications>>.

==== git format-patch

The `git format-patch` command is used to generate a series of patches in mbox format that you can use to send to a mailing list properly formatted.

We go through an example of contributing to a project using the `git format-patch` tool in <<ch05-distributed-git#_project_over_email>>.

==== git imap-send

The `git imap-send` command uploads a mailbox generated with `git format-patch` into an IMAP drafts folder.

We go through an example of contributing to a project by sending patches with the `git imap-send` tool in <<ch05-distributed-git#_project_over_email>>.

==== git send-email

The `git send-email` command is used to send patches that are generated with `git format-patch` over email.

We go through an example of contributing to a project by sending patches with the `git send-email` tool in <<ch05-distributed-git#_project_over_email>>.

==== git request-pull

The `git request-pull` command is simply used to generate an example message body to email to someone.
If you have a branch on a public server and want to let someone know how to integrate those changes without sending the patches over email, you can run this command and send the output to the person you want to pull the changes in.

We demonstrate how to use `git request-pull` to generate a pull message in <<ch05-distributed-git#_public_project>>.

=== External Systems

Git comes with a few commands to integrate with other version control systems.

==== git svn

The `git svn` command is used to communicate with the Subversion version control system as a client.
This means you can use Git to checkout from and commit to a Subversion server.

This command is covered in depth in <<ch09-git-and-other-systems#_git_svn>>.

==== git fast-import

For other version control systems or importing from nearly any format, you can use `git fast-import` to quickly map the other format to something Git can easily record.

This command is covered in depth in <<ch09-git-and-other-systems#_custom_importer>>.

=== Administration

If you're administering a Git repository or need to fix something in a big way, Git provides a number of administrative commands to help you out.

==== git gc

The `git gc` command runs "`garbage collection`" on your repository, removing unnecessary files in your database and packing up the remaining files into a more efficient format.

This command normally runs in the background for you, though you can manually run it if you wish.
We go over some examples of this in <<ch10-git-internals#_git_gc>>.

==== git fsck

The `git fsck` command is used to check the internal database for problems or inconsistencies.

We only quickly use this once in <<ch10-git-internals#_data_recovery>> to search for dangling objects.

==== git reflog

The `git reflog` command goes through a log of where all the heads of your branches have been as you work to find commits you may have lost through rewriting histories.

We cover this command mainly in <<ch07-git-tools#_git_reflog>>, where we show normal usage to and how to use `git log -g` to view the same information with `git log` output.

We also go through a practical example of recovering such a lost branch in <<ch10-git-internals#_data_recovery>>.

==== git filter-branch

The `git filter-branch` command is used to rewrite loads of commits according to certain patterns, like removing a file everywhere or filtering the entire repository down to a single subdirectory for extracting a project.

In <<ch07-git-tools#_removing_file_every_commit>> we explain the command and explore several different options such as `--commit-filter`, `--subdirectory-filter` and `--tree-filter`.

In <<ch09-git-and-other-systems#_git_p4>> we use it to fix up imported external repositories.


=== Plumbing Commands

There were also quite a number of lower level plumbing commands that we encountered in the book.

The first one we encounter is `ls-remote` in <<ch06-github#_pr_refs>> which we use to look at the raw references on the server.

We use `ls-files` in <<ch07-git-tools#_manual_remerge>>, <<ch07-git-tools#ref_rerere>> and <<ch07-git-tools#_the_index>> to take a more raw look at what your staging area looks like.

We also mention `rev-parse` in <<ch07-git-tools#_branch_references>> to take just about any string and turn it into an object SHA-1.

However, most of the low level plumbing commands we cover are in <<ch10-git-internals#ch10-git-internals>>, which is more or less what the chapter is focused on.
We tried to avoid use of them throughout most of the rest of the book.
